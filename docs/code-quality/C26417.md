---
title: C26417
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26417
helpviewer_keywords:
- C26417
ms.assetid: 0e09fcc6-f9eb-4404-b51e-5815705c6afb
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 7c81507b63ce499cd684b1cc10fea03e9975a418
ms.sourcegitcommit: 21d667104199c2493accec20c2388cf674b195c3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/08/2019
ms.locfileid: "55948509"
---
# <a name="c26417-nolvaluerefsharedptr"></a>C26417 NO_LVALUE_REF_SHARED_PTR
« Paramètre de pointeur partagé est passé par référence et pas réinitialisé ou réassigné. Utilisez T * ou T & à la place. »

**C++ Core Guidelines**: R.35 : Prendre un shared_ptr<widget>& paramètre pour exprimer qu’une fonction peut réinstaller le pointeur partagé

Passage de pointeurs partagés par référence peut être utile dans les scénarios où code appelant met à jour la cible de l’objet pointeur intelligent et son appelant s’attend à voir ces mises à jour. À l’aide d’une référence uniquement à réduire les coûts de passer un pointeur partagé est douteux. Si le code appelant accède uniquement aux objet cible et jamais gère sa durée de vie, il est préférable de passer le pointeur brut ou référence, plutôt que d’exposer les détails de gestion de ressources.

## <a name="remarks"></a>Notes
-  Cette vérification reconnaît std::shared_pointer et les types définis par l’utilisateur qui sont susceptibles de se comportent comme des pointeurs partagés. Les caractéristiques suivantes sont attendus pour défini par l’utilisateur de pointeurs partagés :
-  surchargé déréférencer ou d’accès au membre opérateurs (publiques et non supprimé) ;
-  constructeur de copie ou opérateur d’assignation de copie (publique et non supprimé) ;
-  destructeur public qui n’est ni supprimé ni une valeur par défaut. Les destructeurs vides sont toujours comptabilisées comme défini par l’utilisateur.
-  L’action de réinitialisation ou la réaffectation est interprétée de façon plus générique :
-  un appel à une fonction non constante sur un pointeur partagé peut réinitialiser potentiellement le pointeur ;
-  tout appel à une fonction qui accepte une référence à un pointeur partagé non constante peut réinitialiser ou réaffecter ce pointeur.

## <a name="example"></a>Exemple
complication de l’interface inutiles

```cpp
bool unregister(std::shared_ptr<event> &e) // C26417, also C26415 SMART_PTR_NOT_NEEDED
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e))
        e = std::make_shared<event>(e->id());
    // ...
}
```

## <a name="example"></a>Exemple
complication interface inutiles - simplifiée

```cpp
bool unregister(const event *e)
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e.get()))
        e = std::make_shared<event>(e->id());
    // ...
}
```
