---
title: C6278
ms.date: 10/16/2019
ms.topic: reference
f1_keywords:
- C6278
helpviewer_keywords:
- C6278
ms.assetid: 5cc3c393-c48a-4f91-9f38-03d7868be5e5
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: c06fc4df94da5babc204336570591789cabebc9b
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/15/2020
ms.locfileid: "77262624"
---
# <a name="c6278"></a>C6278
AVERTISSEMENT C6278 : \<> de variables est alloué avec un tableau New [], mais supprimé avec une variable scalaire Delete. Les destructeurs ne sont pas appelés

Cet avertissement s’affiche uniquement C++ dans le code et indique que la fonction appelante a alloué de manière incohérente la mémoire avec le tableau **New []** , mais l’a libéré avec l’opérateur scalaire **Delete** . Il s’agit d’un C++ comportement non défini en fonction des implémentations C++ standard et Microsoft. Il existe au moins trois raisons pour lesquelles cela est susceptible de provoquer des problèmes :

- Les constructeurs pour les objets individuels dans le tableau sont appelés, mais les destructeurs ne sont pas appelés.

- Si l’opérateur global ou spécifique à la classe, **operator new** et **operator delete** ne sont pas compatibles avec **operator new []** et **operator delete []** , des résultats inattendus sont susceptibles de se produire.

- Il est toujours risqué de s’appuyer sur un comportement non défini.

Les ramifications exactes de ce défaut sont difficiles à prédire. Cela peut provoquer des fuites pour les classes avec des destructeurs qui effectuent la désallocation de mémoire ; comportement incohérent pour les classes avec des destructeurs qui effectuent une opération sémantiquement significative ; ou des altérations de la mémoire et des blocages quand les opérateurs ont été remplacés. Dans d’autres cas, l’incompatibilité peut être sans importance, en fonction de l’implémentation du compilateur et de ses bibliothèques. L’outil d’analyse ne peut pas toujours faire la distinction entre ces situations.

Si la mémoire est allouée avec **un tableau New []** , elle doit généralement être libérée avec la suppression de tableau **[]** .

## <a name="example"></a>Exemple

L’exemple de code suivant génère cet avertissement :

```cpp
class A
{
  // members
};

void f( )
{
  A *pA = new A[5];
  // code ...
  delete pA;
}
```

Pour corriger cet avertissement, utilisez l’exemple de code suivant :

```cpp
void f( )
{
  A *pA = new A[5];
  // code ...
  delete[] pA;
}
```

Si l’objet sous-jacent dans le tableau est un type primitif, tel que `int`, `float`, `enum`ou un pointeur, aucun destructeur n’est appelé. Dans ce cas, l’avertissement [C6283](../code-quality/c6283.md) est signalé à la place.

L’utilisation des nouvelles et des suppressions présente de nombreux pièges en termes de fuites de mémoire et d’exceptions. Pour éviter l’ensemble de ces types de fuites et de problèmes d’exception, utilisez les mécanismes fournis par C++ la bibliothèque STL (Standard Template Library). Il s’agit notamment des [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)et [Vector](/cpp/standard-library/vector). Pour plus d’informations, consultez [pointeurs intelligents](/cpp/cpp/smart-pointers-modern-cpp) et [ C++ bibliothèque standard](/cpp/standard-library/cpp-standard-library-reference).
