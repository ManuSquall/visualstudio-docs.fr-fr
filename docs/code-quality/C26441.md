---
title: C26441
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: e00411c9a0e7a0abaec92c93562dd40855ee55de
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016329"
---
# <a name="c26441-no_unnamed_guards"></a>C26441 NO_UNNAMED_GUARDS

« Les objets de protection doivent être nommés ».

**C++ Instructions principales**: CP. 44 : N’oubliez pas de nommer vos lock_guards et unique_locks

La bibliothèque standard fournit quelques classes utiles qui permettent de contrôler l’accès simultané aux ressources. Les objets de ce type verrouillent l’accès exclusif pendant toute leur durée de vie. Cela implique que chaque objet Lock doit être nommé, c’est-à-dire avoir une durée de vie clairement définie, qui s’étend sur la période pendant laquelle les opérations d’accès sont exécutées. Par conséquent, l’échec de l’assignation d’un objet Lock à une variable est une erreur qui désactive efficacement le mécanisme de verrouillage (car les variables temporaires sont temporaires). Cette règle tente d’intercepter des cas simples de ce comportement involontaire.

## <a name="remarks"></a>Notes

- Seuls les types de verrous standard sont suivis : std :: scoped_lock, std :: unique_lock et std :: lock_quard.
  - Seuls les appels simples aux constructeurs sont analysés. Une expression d’initialiseur plus complexe peut entraîner des résultats inexacts, mais il s’agit plutôt d’un scénario inhabituel.
  - Les verrous passés comme arguments aux appels de fonction ou retournés en tant que résultats d’appels de fonction sont ignorés.
  - Les verrous créés en tant que temporaires, mais assignés à des références nommées pour étendre leur durée de vie, sont ignorés.

## <a name="example"></a>Exemple

variable dont l’étendue est manquante

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

variable délimitée manquante-corrigée

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```
