---
title: C6384
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6384
helpviewer_keywords:
- C6384
ms.assetid: 9c605b61-1485-49a8-847b-41170193dbf4
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 53dd52dd5380d04a9cf9a8757d76123d347151c3
ms.sourcegitcommit: 174c992ecdc868ecbf7d3cee654bbc2855aeb67d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/06/2019
ms.locfileid: "74877843"
---
# <a name="c6384"></a>C6384
Avertissement C6384 : Division d'un pointeur avec opérateur sizeof par une autre valeur

 Cet avertissement indique qu’un calcul de taille peut être incorrect. Pour calculer le nombre d’éléments dans un tableau, il faut parfois diviser la taille du tableau par la taille du premier élément ; Toutefois, lorsque le tableau est en fait un pointeur, le résultat est généralement différent de celui prévu.

 Si le pointeur est un paramètre de fonction et que la taille de la mémoire tampon n’a pas été passée, il n’est pas possible de calculer la mémoire tampon maximale disponible. Lorsque le pointeur est alloué localement, la taille utilisée dans l’allocation doit être utilisée.

## <a name="example"></a>Exemple
 Le code suivant génère cet avertissement :

```cpp
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, sizeof dest  / sizeof dest[0]);
  }
}
```

 Pour corriger cet avertissement, transmettez la taille de la mémoire tampon comme indiqué dans le code suivant :

```cpp
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, SIZE);
  }
}
```

 Pour corriger cet avertissement à l’aide de la _tcsncpy_s de la fonction de chaîne sécurisée, utilisez le code suivant :

```cpp
void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy_s(dest, SIZE, src, SIZE);
  }
}
```

 Notez que l’utilisation des nouvelles et des suppressions présente de nombreux pièges en termes de fuites de mémoire et d’exceptions. Pour éviter l’ensemble de ces types de fuites et de problèmes d’exception, utilisez les mécanismes fournis par C++ la bibliothèque STL (Standard Template Library). Il s’agit notamment des [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)et [Vector](/cpp/standard-library/vector). Pour plus d’informations, consultez [pointeurs intelligents](/cpp/cpp/smart-pointers-modern-cpp) et [ C++ bibliothèque standard](/cpp/standard-library/cpp-standard-library-reference).

## <a name="see-also"></a>Voir aussi

- [_mbsnbcpy_s, _mbsnbcpy_s_l](/cpp/c-runtime-library/reference/mbsnbcpy-s-mbsnbcpy-s-l)
- [sizeof, opérateur](/cpp/cpp/sizeof-operator)
