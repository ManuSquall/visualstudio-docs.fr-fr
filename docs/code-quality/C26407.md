---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: a22c80dc20fa8d437cd2aac71a3a857ff4f68165
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261242"
---
# <a name="c26407-dont_heap_allocate_unnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Pour éviter une utilisation inutile des pointeurs, nous essayons de détecter des modèles courants d’allocations locales, par exemple quand le résultat d’un appel à operator new est stocké dans une variable locale et supprimé explicitement. Cela prend en charge la règle R. 5 : *préférer les objets délimités, pas de tas-Allocate inutilement*. La solution recommandée consiste à utiliser un type RAII au lieu d’un pointeur brut et à l’autoriser à gérer les ressources. Si une allocation est un objet unique, il peut être manifestement inutile et une variable locale du type de l’objet fonctionnerait mieux.

## <a name="remarks"></a>Notes
- Pour réduire le nombre d’avertissements, ce modèle est détecté uniquement pour les pointeurs propriétaires. Par conséquent, il est nécessaire de marquer d’abord les propriétaires correctement. Nous pouvons facilement l’étendre pour couvrir les pointeurs bruts si nous recevons des commentaires des clients qui prennent en charge ce type de scénario.
- Le terme de l’objet étendu peut être un peu trompeur, mais l’idée générale est que nous suggérons d’utiliser une variable locale dont la durée de vie est gérée automatiquement, ou un objet intelligent qui gère efficacement les ressources dynamiques. Les objets intelligents peuvent bien entendu faire des allocations de tas, mais ce n’est pas explicite dans le code.
- Si l’avertissement se déclenche sur l’allocation de tableau (ce qui est généralement nécessaire pour les mémoires tampons dynamiques), le correctif peut consister à utiliser des conteneurs standard ou `std::unique_pointer<T[]>`.
- Le modèle est détecté uniquement pour les variables locales, donc nous n’avertissons pas dans les cas où une allocation est assignée à, par exemple, une variable globale, puis supprimée dans la même fonction.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Exemple 1 : allocation d’objets inutile sur le tas

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Exemple 2 : allocation d’objets inutile sur le segment de mémoire (fixe avec objet local)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Exemple 3 : allocation de mémoire tampon inutile sur le tas

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Exemple 4 : allocation de mémoire tampon inutile sur le tas (fixe avec le conteneur)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
