---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 771f3e45403141e1e77da2dc941f3e08831577c2
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011834"
---
# <a name="c26407-dont_heap_allocate_unnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY
Pour éviter une utilisation inutile des pointeurs, nous essayons de détecter des modèles courants d’allocations locales, par exemple quand le résultat d’un appel à operator new est stocké dans une variable locale et supprimé explicitement. Cela prend en charge la règle R. 5 : *Préférer les objets délimités, pas de tas-Allocate inutilement*. La solution recommandée consiste à utiliser un type RAII au lieu d’un pointeur brut et à l’autoriser à gérer les ressources. Si une allocation est un objet unique, il peut être manifestement inutile et une variable locale du type de l’objet fonctionnerait mieux.

## <a name="remarks"></a>Notes
- Pour réduire le nombre d’avertissements, ce modèle est détecté uniquement pour les pointeurs propriétaires. Par conséquent, il est nécessaire de marquer d’abord les propriétaires correctement. Nous pouvons facilement l’étendre pour couvrir les pointeurs bruts si nous recevons des commentaires des clients qui prennent en charge ce type de scénario.
- Le terme de l’objet étendu peut être un peu trompeur, mais l’idée générale est que nous suggérons d’utiliser une variable locale dont la durée de vie est gérée automatiquement, ou un objet intelligent qui gère efficacement les ressources dynamiques. Les objets intelligents peuvent bien entendu faire des allocations de tas, mais ce n’est pas explicite dans le code.
- Si l’avertissement se déclenche sur l’allocation de tableau (ce qui est généralement nécessaire pour les mémoires tampons dynamiques), le correctif peut être l’utilisation de conteneurs standard ou `std::unique_pointer<T[]>`.
- Le modèle est détecté uniquement pour les variables locales, donc nous n’avertissons pas dans les cas où une allocation est assignée à, par exemple, une variable globale, puis supprimée dans la même fonction.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Exemple 1 : Allocation d’objets inutile sur le tas

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Exemple 2 : Allocation d’objets inutile sur le segment de mémoire (fixe avec objet local)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Exemple 3 : Allocation de mémoire tampon inutile sur le tas

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Exemple 4 : Allocation de mémoire tampon inutile sur le tas (fixe avec le conteneur)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
